// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace 
#nullable restore
#line 1 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\Cropper\VezaVIImageCropper.razor"
           VezaVI.Light.Components

#line default
#line hidden
#nullable disable
{
    #line default
    using global::System.Collections.Generic;
    using global::System.Threading.Tasks;
    using global::Microsoft.AspNetCore.Components;
#nullable restore
#line 1 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Net.Http

#nullable disable
    ;
#nullable restore
#line 2 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.AspNetCore.Components.Forms

#nullable disable
    ;
#nullable restore
#line 3 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.AspNetCore.Components.Routing

#nullable disable
    ;
#nullable restore
#line 4 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.AspNetCore.Components.Web

#nullable disable
    ;
#nullable restore
#line 5 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.JSInterop

#nullable disable
    ;
#nullable restore
#line 6 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.AspNetCore.Authorization

#nullable disable
    ;
#nullable restore
#line 7 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Text.Json

#nullable disable
    ;
#nullable restore
#line 8 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Net.Http.Headers

#nullable disable
    ;
#nullable restore
#line 9 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using VezaVI.Light.Shared

#nullable disable
    ;
#nullable restore
#line 10 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Blazored.Modal

#nullable disable
    ;
#nullable restore
#line 11 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Blazored.Modal.Services

#nullable disable
    ;
#nullable restore
#line 12 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Linq

#nullable disable
    ;
#nullable restore
#line 13 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Blazored.LocalStorage

#nullable disable
    ;
#nullable restore
#line 14 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Text

#nullable disable
    ;
#nullable restore
#line 15 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System.Net.Http.Json

#nullable disable
    ;
#nullable restore
#line 16 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using Microsoft.AspNetCore.Components.Web.Virtualization

#nullable disable
    ;
#nullable restore
#line 17 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using SixLabors.ImageSharp.Processing

#nullable disable
    ;
#nullable restore
#line 18 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using SixLabors.ImageSharp.Formats

#nullable disable
    ;
#nullable restore
#line 19 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using System

#nullable disable
    ;
#nullable restore
#line 20 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\_Imports.razor"
using SixLabors.ImageSharp

#line default
#line hidden
#nullable disable
    ;
    #nullable restore
    public partial class VezaVIImageCropper : global::Microsoft.AspNetCore.Components.ComponentBase
    #nullable disable
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(global::Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
        }
        #pragma warning restore 1998
#nullable restore
#line 44 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\Cropper\VezaVIImageCropper.razor"
       
#region params
    /// <summary>
    /// the initial width of cropper if possible
    /// </summary>
    /// <value>default: 150</value>
    [Parameter]
    public double InitCropWidth { get; set; } = 150;
    /// <summary>
    /// the initial height of cropper if possible
    /// </summary>
    /// <value>default: 150</value>
    [Parameter]
    public double InitCropHeight { get; set; } = 150;
    /// <summary>
    /// sepecify whether the cropper's aspect ratio is fixed
    /// </summary>
    /// <value>default: false</value>
    [Parameter]
    public bool RequireAspectRatio { get; set; } = false;
    /// <summary>
    /// sepecify the cropper's aspect ratio
    /// </summary>
    /// <remarks>Only works when <see cref="RequireAspectRatio"/> is true</remarks>
    /// <value>default: 1</value>
    [Parameter]
    public double AspectRatio { get; set; } = 1;
    /// <summary>
    /// The input image file. Usually get from an <see cref="InputFile"/> Component
    /// </summary>
    /// <value></value>
    [Parameter]
    public IBrowserFile ImageFile { get; set; }
    /// <summary>
    /// Fire when the image file load into cropper
    /// </summary>
    /// <value></value>
    [Parameter]
    public EventCallback OnLoad { get; set; }
    /// <summary>
    /// Set whether the anime gif crop is enabled. If enabled, the gif file smaller than 1mb would 
    /// be cropped as animed image. If disabled, only the first frame would be cropped.
    /// </summary>
    /// <remarks>Resizing gif image can cause the window stop responding for half a minute!</remarks>
    /// <value>default: false</value>
    [Parameter]
    public bool AnimeGifEnable { get; set; } = false;
    /// <summary>
    /// The input element's id value. THIS VALUE MUST BE SET ON INIT!
    /// </summary>
    [Parameter]
    public string InputId { get; set; }
    /// <summary>
    /// Max allowed crop result height. Should not be larger than 500.
    /// </summary>
    /// <value>default:500</value>
    [Parameter]
    public double MaxCropedHeight { get; set; } = 500;
    /// <summary>
    /// Max allowed crop result width. Should not be larger than 500.
    /// </summary>
    /// <value>default:500</value>
    [Parameter]
    public double MaxCropedWidth { get; set; } = 500;
    /// <summary>
    /// Height of this component in px
    /// </summary>
    /// <value>default:150</value>
    [Parameter]
    public double CropperHeight { get; set; } = 150;
    /// <summary>
    /// The scaling ratio, should be bind two way.
    /// </summary>
    /// <value>default: 1.0</value>
    [Parameter]
    public double Ratio { get; set; } = 1.0;
    /// <summary>
    /// Fire when scaling ratio changed by touch event.
    /// </summary>
    [Parameter]
    public EventCallback<double> RatioChanged { get; set; }
#endregion


#region public vars
    /// <summary>
    /// Max allowed scaling ratio
    /// </summary>
    /// <value></value>
    public double MaxRatio { get; private set; }
    /// <summary>
    /// Min allowed scaling ratio
    /// </summary>
    /// <value>1.0</value>
    public double MinRatio { get => 1.0; }
#endregion


#region private props
    bool widerThenContainer
    {
        get => (double)image.Width / (double)image.Height > imgContainerWidth / imgContainerHeight;
    }
    double imgRealW
    {
        get
        {
            if (widerThenContainer)
            {
                return imgContainerWidth * imgSize / 100;
            }
            else
            {
                return imgContainerHeight * imgSize / 100 * (double)image.Width / image.Height;
                

#line default
#line hidden
#nullable disable

#nullable restore
#line 158 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\Cropper\VezaVIImageCropper.razor"
                                                                           
            }
        }
    }
    double imgRealH
    {
        get
        {
            if (widerThenContainer)
            {
                return imgContainerWidth * imgSize / 100 * (double)image.Height / image.Width;
            }
            else
            {
                return imgContainerHeight * imgSize / 100;
            }
        }
    }
    string backgroundImgStyle
    {
        get => $"left:{bacx}px;top: {bacy}px;width:{imgSize}%;height:{imgSize}%;";
    }
    string imglistStyle
    {
        get => $"height:{CropperHeight}px;";
    }
#endregion


#region vars
    double prevBacX = 0;
    double prevBacY = 0;
    double bacx = 0;
    double bacy = 0;
    double imgSize = 100;
    bool onTwoFingerResizing = false;
    bool isBacMoving = false;
    double prevTouchPointDistance = -1;
    double imgContainerWidth = 500;
    double imgContainerHeight = 150;
    double prevPosX = 0;
    double prevPosY = 0;
    double layoutX = 0;
    double layoutY = 0;
    double offsetX;
    double offsetY;
    string cropperStyle = "";
    string cropedImgStyle = "clip: rect(0, 150px, 150px, 0);";
    bool dragging = false;
    bool reSizing = false;
    MoveDir dir = MoveDir.UnKnown;
    double minval = 30;
    ImageData image;
    double minposX;
    double minposY;
    double imgw;
    double imgh;
    double unsavedX;
    double unsavedY;
    double unsavedCropW;
    double unsavedCropH;
    bool outOfBox = false;
    IBrowserFile prevFile;
    IImageFormat format;
    Image gifimage;

#endregion


#region static actions
    static Action setaction;
    static Action<MouseEventArgs> mouseMoveAction;
    static Action<MouseEventArgs> touchMoveAction;
    static Action<MouseEventArgs> touchEndAction;
    static Action<MouseEventArgs> mouseUpAction;
#endregion



#region Override methods
    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        if (MinRatio <= Ratio && Ratio <= MaxRatio && !onTwoFingerResizing)
        {
            var temp = imgSize;
            imgSize = Ratio * 100;
            if (widerThenContainer)
            {
                minposX = 0;
                minposY = (imgContainerHeight - imgRealH) / 2;
            }
            else
            {
                minposY = 0;
                minposX = (imgContainerWidth - imgRealW) / 2;
            }
            minposY += bacy - (imgSize - temp) / imgSize * imgRealH / 2;
            minposX += bacx;
            if (prevPosX + InitCropWidth > minposX + imgRealW || prevPosX < minposX
                || prevPosY + InitCropHeight > minposY + imgRealH || prevPosY < minposY)
            {
                imgSize = temp;
                await RatioChanged.InvokeAsync(imgSize / 100);
            }
            else
            {
                bacy -= (imgSize - temp) / imgSize * imgRealH / 2;
                layoutY -= (imgSize - temp) / imgSize * imgRealH / 2;
                SetCroppedImgStyle();
            }
            InitBox();
        }
        if (RequireAspectRatio)
        {
            if (InitCropHeight > InitCropWidth * AspectRatio)
            {
                InitCropHeight = InitCropWidth * AspectRatio;
            }
            else
            {
                InitCropWidth = InitCropHeight / AspectRatio;
            }
            SetCropperStyle();
            SetCroppedImgStyle();
        }
        if (prevFile == ImageFile)
        {
            return;
        }
        else
        {
            prevFile = ImageFile;
        }
        var ext = ImageFile.Name.Split('.').Last().ToLower();
        var resizedImageFile = ImageFile;
        await Task.Delay(10);
        await JSRuntime.InvokeVoidAsync("setImg", InputId);
        var data = new double[] { 0, 0 };
        while (data[0] == 0d)
        {
            await Task.Delay(10);
            data = await JSRuntime.InvokeAsync<double[]>("getOriImgSize");
        }

        gifimage?.Dispose();
        if (ext == "gif" && AnimeGifEnable && resizedImageFile.Size < 1048576)
        {
            var buffer = new byte[resizedImageFile.Size];
            await resizedImageFile.OpenReadStream(100000000).ReadAsync(buffer);
            gifimage = Image.Load(buffer, out format);
        }
        image = new ImageData
        {
            Width = data[0],
            Height = data[1]
        };
        await SetImgContainterSize();
        MaxRatio = imgContainerWidth / imgRealW;
        await RatioChanged.InvokeAsync(imgSize / 100);
        await OnLoad.InvokeAsync();
    }
    protected override async Task OnAfterRenderAsync(bool first)
    {
        await base.OnAfterRenderAsync(first);
        if (first)
        {
            setaction = () => SetImgContainterSize();
            mouseMoveAction = args =>
            {
                OnSizeChanging(args);
                OnResizeBackGroundImage(MouseToTouch(args));
            };
            mouseUpAction = args =>
            {
                if (onTwoFingerResizing || isBacMoving)
                {
                    isBacMoving = false;
                    onTwoFingerResizing = false;
                    InitBox();
                }
                OnSizeChangeEnd(args);
            };
            touchMoveAction = OnSizeChanging;
            touchEndAction = (args) =>
            {
                outOfBox = true;
                OnSizeChangeEnd(args);
            };

            await JSRuntime.InvokeVoidAsync("console.log", imgContainerWidth, imgContainerHeight);
        }
    }
#endregion

#region JsInvokable methods
    [JSInvokable("OnTouchEnd")]
    public static void TouchEndCaller(MouseEventArgs args)
    {
        touchEndAction?.Invoke(args);
    }
    [JSInvokable("OnTouchMove")]
    public static void TouchMoveCaller(MouseEventArgs args)
    {
        touchMoveAction?.Invoke(args);
    }
    [JSInvokable("OnMouseUp")]
    public static void MouseUpCaller(MouseEventArgs args)
    {
        mouseUpAction?.Invoke(args);
    }
    [JSInvokable("OnMouseMove")]
    public static void MouseMoveCaller(MouseEventArgs args)
    {
        mouseMoveAction?.Invoke(args);
    }
    [JSInvokable("SetWidthHeight")]
    public static void SetWidthHeightCaller()
    {
        setaction?.Invoke();
    }
#endregion


#region Public methods
    /// <summary>
    /// Get the crop result.
    /// </summary>
    /// <returns>crop result</returns>
    public async Task<ImageCroppedResult> GetCropedResult()
    {
        var deltaX = 0;
        var deltaY = 0;
        var i = 0d;
        if (widerThenContainer)
        {
            imgContainerWidth *= imgSize / 100;
            i = imgContainerWidth / image.Width;
            deltaY = -(int)(imgContainerHeight / i - image.Height) / 2;
        }
        else
        {
            imgContainerHeight *= imgSize / 100;
            i = imgContainerHeight / image.Height;
            deltaX = -(int)(imgContainerWidth / i - image.Width) / 2;
        }
        var resizeProp = 1d;
        var cw = (InitCropWidth / i);
        var ch = (InitCropHeight / i);
        if (cw > MaxCropedWidth || ch > MaxCropedHeight)
        {
            if (MaxCropedWidth / MaxCropedHeight > (double)cw / (double)ch)
            {
                resizeProp = MaxCropedHeight / ch;
            }
            else
            {
                resizeProp = MaxCropedWidth / cw;
            }
        }
        var s = "";
        if (gifimage == null)
        {
            s = await JSRuntime.InvokeAsync<string>("cropAsync", "oriimg", (int)((prevPosX - bacx) / i + deltaX), (int)((prevPosY - bacy) / i + deltaY),
                (int)(cw), (int)(ch), 0, 0, (int)(cw * resizeProp), (int)(ch * resizeProp), "image/png");
        }
        else
        {
            s = gifimage.Clone(ctx =>
            {
                ctx.Crop(new Rectangle((int)((prevPosX - bacx) / i + deltaX), (int)((prevPosY - bacy) / i + deltaY), (int)(cw), (int)(ch)));
                if (resizeProp != 1d)
                {
                    ctx.Resize(new Size((int)(cw * resizeProp), (int)(ch * resizeProp)));
                }
            }).ToBase64String(format);
        }
        return new ImageCroppedResult
        {
            Base64 = s
        };
    }
#endregion


#region private methods
    void SetCroppedImgStyle()
    {
        cropedImgStyle =$"clip: rect({prevPosY - layoutY}px, {prevPosX - layoutX + InitCropWidth}px, {prevPosY - layoutY + InitCropHeight}px, {prevPosX - layoutX}px);";
    }
    void SetCropperStyle()
    {
        cropperStyle = $"top:{prevPosY}px;left:{prevPosX}px;cursor:move;height:{InitCropHeight}px;width:{InitCropWidth}px";
    }

    MouseEventArgs TouchToMouse(TouchEventArgs args)
    {
        try
        {
            return new MouseEventArgs()
            {
                ClientX = args.Touches[0].ClientX,
                ClientY = args.Touches[0].ClientY
            };
        }
        catch (System.Exception)
        {
            outOfBox = true;
            return new MouseEventArgs();
        }
    }

    void OnDragStart(MouseEventArgs args)
    {
        outOfBox = false;
        if (reSizing)
        {
            return;
        }
        SetCropperStyle();
        offsetX = args.ClientX;
        offsetY = args.ClientY;
        dragging = true;
    }
    void OnDragging(MouseEventArgs args)
    {
        if (dragging && !reSizing)
        {
            var x = prevPosX - offsetX + args.ClientX;
            var y = prevPosY - offsetY + args.ClientY;
            if (y < minposY)
            {
                outOfBox = true;
                y = minposY;
            }
            if (x < minposX)
            {
                outOfBox = true;
                x = minposX;
            }
            if (y + InitCropHeight > (minposY + imgh))
            {
                outOfBox = true;
                y = (minposY + imgh) - InitCropHeight;
            }
            if (x + InitCropWidth > (minposX + imgw))
            {
                outOfBox = true;
                x = (minposX + imgw) - InitCropWidth;
            }
            unsavedX = x;
            unsavedY = y;
            cropperStyle = $"top:{y}px;left:{x}px;height:{InitCropHeight}px;width:{InitCropWidth}px";
            cropedImgStyle = $"clip: rect({y - layoutY}px, {x - layoutX + InitCropWidth}px, {y - layoutY + InitCropHeight}px, {x - layoutX}px);";
            base.StateHasChanged();
        }
    }
    void OnDragEnd(MouseEventArgs args)
    {
        dragging = false;
        OnDragging(args);
        if (outOfBox)
        {
            prevPosX = unsavedX;
            prevPosY = unsavedY;
            return;
        }
        prevPosX = prevPosX - offsetX + args.ClientX;
        prevPosY = prevPosY - offsetY + args.ClientY;
    }
    void OnResizeStart(MouseEventArgs args, MoveDir dir)
    {
        outOfBox = false;
        this.dir = dir;
        if (dragging)
        {
            return;
        }
        SetCropperStyle();
        offsetX = args.ClientX;
        offsetY = args.ClientY;
        reSizing = true;
    }
    void OnSizeChanging(MouseEventArgs args)
    {
        if (reSizing && !dragging)
        {
            var delta = args.ClientY - offsetY;
            var deltaX = args.ClientX - offsetX;
            var ytemp = prevPosY;
            var tempCropHeight = InitCropHeight;
            var xtemp = prevPosX;
            var tempCropWidth = InitCropWidth;
            switch (dir)
            {
                case MoveDir.Up:
                    {
                        ytemp = prevPosY + delta;
                        tempCropHeight = InitCropHeight - delta;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Down:
                    {
                        tempCropHeight = InitCropHeight + delta;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Left:
                    {
                        xtemp = prevPosX + deltaX;
                        tempCropWidth = InitCropWidth - deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropHeight = tempCropWidth * AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Right:
                    {
                        tempCropWidth = InitCropWidth + deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropHeight = tempCropWidth * AspectRatio;
                        }
                        break;
                    }
                case MoveDir.UpLeft:
                    {
                        ytemp = prevPosY + delta;
                        tempCropHeight = InitCropHeight - delta;
                        tempCropWidth = InitCropWidth - deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                            deltaX = InitCropWidth - tempCropWidth;
                        }
                        xtemp = prevPosX + deltaX;
                        break;
                    }
                case MoveDir.UpRight:
                    {
                        ytemp = prevPosY + delta;
                        tempCropHeight = InitCropHeight - delta;
                        tempCropWidth = InitCropWidth + deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.DownLeft:
                    {
                        tempCropHeight = InitCropHeight + delta;
                        tempCropWidth = InitCropWidth - deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                            deltaX = InitCropWidth - tempCropWidth;
                        }
                        xtemp = prevPosX + deltaX;
                        break;
                    }
                case MoveDir.DownRight:
                    {
                        tempCropHeight = InitCropHeight + delta;
                        tempCropWidth = InitCropWidth + deltaX;
                        if (RequireAspectRatio)
                        {
                            tempCropWidth = tempCropHeight / AspectRatio;
                        }
                        break;
                    }
                default:
                    break;
            }
            if (ytemp < minposY)
            {
                outOfBox = true;
                ytemp = minposY;
            }
            if (xtemp < minposX)
            {
                outOfBox = true;
                xtemp = minposX;
            }
            if (ytemp + tempCropHeight > (minposY + imgh))
            {
                outOfBox = true;
                tempCropHeight = (minposY + imgh) - ytemp;
                if (RequireAspectRatio)
                {
                    tempCropWidth = tempCropHeight / AspectRatio;
                }
            }
            if (xtemp + tempCropWidth > (minposX + imgw))
            {
                outOfBox = true;
                tempCropWidth = (minposX + imgw) - xtemp;
                if (RequireAspectRatio)
                {
                    tempCropHeight = tempCropWidth / AspectRatio;
                }
            }
            if (tempCropHeight < minval)
            {
                tempCropHeight = minval;
                ytemp = unsavedY;
                xtemp = unsavedX;
            }
            if (tempCropWidth < minval)
            {
                tempCropWidth = minval;
                ytemp = unsavedY;
                xtemp = unsavedX;
            }
            unsavedX = xtemp;
            unsavedY = ytemp;
            unsavedCropH = tempCropHeight;
            unsavedCropW = tempCropWidth;
            cropperStyle = $"top:{ytemp}px;left:{xtemp}px;height:{tempCropHeight}px;width:{tempCropWidth}px";
            cropedImgStyle = $"clip: rect({ytemp - layoutY}px, {xtemp - layoutX + tempCropWidth}px, {ytemp - layoutY + tempCropHeight}px, {xtemp - layoutX}px);";
        }
        OnDragging(args);
        base.StateHasChanged();
    }
    void OnSizeChangeEnd(MouseEventArgs args)
    {
        if (reSizing)
        {
            reSizing = false;
            OnSizeChanging(args);
            var delta = args.ClientY - offsetY;
            var deltaX = args.ClientX - offsetX;
            if (outOfBox)
            {
                InitCropHeight = unsavedCropH;
                InitCropWidth = unsavedCropW;
                prevPosY = unsavedY;
                prevPosX = unsavedX;
                return;
            }
            switch (dir)
            {
                case MoveDir.Up:
                    {
                        prevPosY = prevPosY + delta;
                        InitCropHeight -= delta;
                        if (RequireAspectRatio)
                        {
                            InitCropWidth = InitCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Down:
                    {
                        InitCropHeight += delta;
                        if (RequireAspectRatio)
                        {
                            InitCropWidth = InitCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Left:
                    {
                        prevPosX += deltaX;
                        InitCropWidth -= deltaX;
                        if (RequireAspectRatio)
                        {
                            InitCropHeight = InitCropWidth * AspectRatio;
                        }
                        break;
                    }
                case MoveDir.Right:
                    {
                        InitCropWidth += deltaX;
                        if (RequireAspectRatio)
                        {
                            InitCropHeight = InitCropWidth * AspectRatio;
                        }
                        break;
                    }
                case MoveDir.UpLeft:
                    {
                        prevPosY = prevPosY + delta;
                        InitCropHeight -= delta;
                        if (RequireAspectRatio)
                        {
                            var ori = InitCropWidth;
                            InitCropWidth = InitCropHeight / AspectRatio;
                            deltaX = ori - InitCropWidth;
                            prevPosX += deltaX;
                        }
                        else
                        {
                            prevPosX += deltaX;
                            InitCropWidth -= deltaX;
                        }
                        break;
                    }
                case MoveDir.UpRight:
                    {
                        prevPosY = prevPosY + delta;
                        InitCropHeight -= delta;
                        InitCropWidth += deltaX;
                        if (RequireAspectRatio)
                        {
                            InitCropWidth = InitCropHeight / AspectRatio;
                        }
                        break;
                    }
                case MoveDir.DownLeft:
                    {
                        InitCropHeight += delta;
                        if (RequireAspectRatio)
                        {
                            var ori = InitCropWidth;
                            InitCropWidth = InitCropHeight / AspectRatio;
                            deltaX = ori - InitCropWidth;
                            prevPosX += deltaX;
                        }
                        else
                        {
                            prevPosX += deltaX;
                            InitCropWidth -= deltaX;
                        }
                        break;
                    }
                case MoveDir.DownRight:
                    {
                        InitCropHeight += delta;
                        InitCropWidth += deltaX;
                        if (RequireAspectRatio)
                        {
                            InitCropWidth = InitCropHeight / AspectRatio;
                        }
                        break;
                    }
                default:
                    break;
            }
            if (InitCropHeight < minval)
            {
                InitCropHeight = minval;
            }
            if (InitCropWidth < minval)
            {
                InitCropWidth = minval;
            }
        }
        if (dragging)
        {
            OnDragEnd(args);
        }
    }
    TouchEventArgs MouseToTouch(MouseEventArgs args)
    {
        return new TouchEventArgs
        {
            Touches = new[]{
                new TouchPoint{
                ClientX = args.ClientX,
                ClientY = args.ClientY
            }
            }
        };
    }
    void ResizeBac(double i)
    {
        var temp = imgSize;
        if (imgSize * i < 100 && i < 1)
        {
            return;
        }
        if ((imgRealW * i > imgContainerWidth) && (imgRealH * i > imgContainerHeight) && i > 1)
        {
            return;
        }
        imgSize *= i;




        if (widerThenContainer)
        {
            minposX = 0;
            minposY = (imgContainerHeight - imgRealH) / 2;
        }
        else
        {
            minposY = 0;
            minposX = (imgContainerWidth - imgRealW) / 2;
        }
        minposY += bacy - (imgSize - temp) / imgSize * imgRealH / 2;
        minposX += bacx;
        if (prevPosX + InitCropWidth > minposX + imgRealW || prevPosX < minposX
            || prevPosY + InitCropHeight > minposY + imgRealH || prevPosY < minposY)
        {
            imgSize /= i;
        }
        else
        {
            bacy -= (i - 1) * imgRealH / 2;
            layoutY -= (i - 1) * imgRealH / 2;
            SetCroppedImgStyle();
        }
    }
    void OnResizeBackGroundImage(TouchEventArgs args)
    {
        if (args.Touches.Length == 1)
        {
            if (!isBacMoving)
            {
                return;
            }
            var dx = args.Touches[0].ClientX - prevBacX;
            var dy = args.Touches[0].ClientY - prevBacY;
            if (widerThenContainer)
            {
                minposX = 0;
                minposY = (imgContainerHeight - imgRealH) / 2;
            }
            else
            {
                minposY = 0;
                minposX = (imgContainerWidth - imgRealW) / 2;
            }
            minposY += bacy + dy;
            minposX += bacx + dx;
            bacx += dx;
            bacy += dy;
            layoutX += dx;
            layoutY += dy;
            if (prevPosX + InitCropWidth > minposX + imgRealW || prevPosX < minposX)
            {
                bacx -= dx;
                layoutX -= dx;
                minposX -= bacx;
            }
            if (prevPosY + InitCropHeight > minposY + imgRealH || prevPosY < minposY)
            {
                bacy -= dy;
                layoutY -= dy;
                minposY -= bacy;
            }
            SetCroppedImgStyle();
            prevBacX = args.Touches[0].ClientX;
            prevBacY = args.Touches[0].ClientY;
        }
        if (args.Touches.Length != 2)
        {
            return;
        }
        var distance = Math.Pow((args.Touches[0].ClientX - args.Touches[1].ClientX), 2) +
            Math.Pow((args.Touches[0].ClientY - args.Touches[1].ClientY), 2);
        if (onTwoFingerResizing)
        {
            var i = distance / prevTouchPointDistance;
            ResizeBac(i);

            RatioChanged.InvokeAsync(imgSize / 100);
        }
        else
        {
            onTwoFingerResizing = true;
        }
        prevTouchPointDistance = distance;

    }
    async Task SetImgContainterSize()
    {
        var t = await JSRuntime.InvokeAsync<double[]>("getWidthHeight");
        // in the case that container has not yet loaded 
        while (t[0] == 0)
        {
            await Task.Delay(10);
            t = await JSRuntime.InvokeAsync<double[]>("getWidthHeight");
        }
        imgContainerWidth = t[0];
        imgContainerHeight = t[1];
        InitStyles();
    }
    void InitBox()
    {
        var prevPosX = 0d;
        var prevPosY = 0d;
        if (widerThenContainer)
        {
            prevPosY = (imgContainerHeight - imgRealH) / 2;
            prevPosX = 0;
        }
        else
        {
            prevPosX = Math.Abs(imgContainerWidth - imgRealW) / 2;
            prevPosY = 0;
        }
        prevPosY += bacy;
        prevPosX += bacx;
        minposX = prevPosX;
        minposY = prevPosY;
        imgw = imgRealW;
        imgh = imgRealH;
    }
    void InitStyles()
    {
        var i = 0d;
        if (widerThenContainer)
        {
            i = imgContainerWidth / image.Width;
            prevPosY = (imgContainerHeight - imgRealH) / 2;
            prevPosX = 0;
        }
        else
        {
            i = imgContainerHeight / image.Height;
            prevPosX = Math.Abs(imgContainerWidth - imgRealW) / 2;
            prevPosY = 0;
        }
        prevPosY += bacy;
        prevPosX += bacx;
        minposX = prevPosX;
        minposY = prevPosY;
        imgw = imgRealW;
        imgh = imgRealH;
        if (InitCropHeight > imgh)
        {
            InitCropHeight = imgh;
        }
        if (InitCropWidth > imgw)
        {
            InitCropWidth = imgw;
        }
        JSRuntime.InvokeVoidAsync("console.log", imgContainerWidth, imgContainerHeight, imgRealW, imgRealH, bacx);

        SetCropperStyle();
        SetCroppedImgStyle();
        base.StateHasChanged();
    }
#endregion

#line default
#line hidden
#nullable disable

        [global::Microsoft.AspNetCore.Components.InjectAttribute] private 
#nullable restore
#line 2 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\Cropper\VezaVIImageCropper.razor"
        IJSRuntime

#line default
#line hidden
#nullable disable
         
#nullable restore
#line 2 "D:\Code\CloudberrySoftwareSolutions\SST-Law\ContractBuilder-main\SST\Shared Libraries\VezaVI.Components\Cropper\VezaVIImageCropper.razor"
                   JSRuntime

#line default
#line hidden
#nullable disable
         { get; set; }
         = default!;
    }
}
#pragma warning restore 1591
